///--------------------------------------------------------------------------///

@import
  'type',
  'contains';

///--------------------------------------------------------------------------///

$_DEBUG: false;

///
/// @method get
/// gets a property (or properties) from a map
/// @param map {map} the map to get from
/// @param key {string|list} can be a string (OR list, for nested maps)
/// @return value {any} the target map/key:value
///

@function get( $map, $key, $update: false, $value: null ){
  
  $m: $map; 
  $v: $value;
  $original: $map;
  $_maps: 1;
  $maps: ();
  
  @if $update {
    $maps: map-merge( $maps, ( map#{$_maps}: $m ) );
  }
  
  //check key type
  $kt: type( $key );

  //handle deep maps via key list
  @if $kt == list {
    
    @if $_DEBUG { @debug 'key list detected'; }
    
    $l: length($key);
    
    $i: 0;
    
    @each $k in $key {
      
      $i: $i + 1;
      
      @if $_DEBUG { @debug 'searching for key #{$i}: #{$k}'; }
      
      //keep digging until target map/key
      $h: has( $m, $k );
      
      @if $h {
        
        @if $_DEBUG { @debug 'found #{$k} in map #{$i}'; }
        
        $x: map-get( $m, $k );
        
        //check for map
        @if type( $x, map ) {
          @if $_DEBUG { @debug 'key #{$k} is map, going recursive'; }
          $m: $x;
          @if $update {
            @if $_DEBUG { @debug 'm is #{ type-of( $m ) }'; }
            $maps: map-merge( $maps, ( map#{$_maps}: $m ) );
            $_maps: $_maps + 1;
          }
        }
        //if property is not map
        @else {
          @if $_DEBUG { @debug 'checking if last'; }
          //check if last
          @if( $i == $l ){ 
            @if $_DEBUG { @debug 'is last'; }
            //assign map and key for map-merge
            $map: $m;
            $key: $k; 
          }
        }        
      } 
      @else {
        @error 'get( $map, $key ) there is no key #{$k} in map #{$i} ';
      }
    }
  }
  
  @if $update {
   $l: length( $maps );
   $i: $l;
   $last: null;
   //recreate each map from last to first
   @while $l >= $i {
     @if $_DEBUG { @debug 'processing #{$i} of #{$l}'; }
     $mk: map#{$i};
     @if $_DEBUG { @debug 'getting #{$mk}'; }
     $x: map-get( $maps, $mk );
     @if type( $x ) != map {
       @warn 'update could not fetch #{$mk}';
     }
     @if $_DEBUG { @debug 'x is #{ type-of( $x ) }'; }
     //if last in maps
     @if $i == $l {
       //add key:value to map
       $last: map-merge( $x, ( $key: $value ) );
     } @else {
       //update map with previous
       $last: map-merge( $x, $last )
     }     
     $i: $i - 1;
     //return final map
     @if $i == 0 { @return $last; }
   }  
  }
  @else {
    $v: map-get( $map, $key );
  }
  
  @return $v;
  
}
///--------------------------------------------------------------------------///

@if $_DEBUG {
  
  $m1: ( a: map, b: value );
  $r: get( $m1, a ) == map;
  @debug 'get works: #{ $r }';
  
  $m2: ( a: ( b: deepmap ) );
  $r: get( $m2, ( a, b ) ) == deepmap;
  @debug 'get [deep] works: #{ $r }';  
  	  
  $r: get( $m1, a, true, newvar );
  $r: map-get( $r, a ) == newvar;
  @debug 'get [update] works: #{ $r }';
    
  $r: get( $m2, a b, true, newvar );
  $r: map-get( $r, b ) == newvar;
  @debug 'get [update deep] works: #{ $r }';
  
  $r: get( $m2, a b c );
  @debug 'get [fake key] works: #{ $r }';
  
}

///--------------------------------------------------------------------------///